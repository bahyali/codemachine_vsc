# System Architecture Blueprint: Code Machine Orchestrator

**Version:** 1.0
**Date:** November 18, 2025
**Generated By:** AI System Architect

## 1. Introduction & Goals

*   **1.1. Project Vision:**
    The **Code Machine Orchestrator** is a VS Code Extension designed to bridge the gap between "black-box" AI code generation and human architectural oversight. It serves as an interactive GUI wrapper for a local Python CLI pipeline, transforming a "fire-and-forget" automation script into a collaborative "Human-in-the-Loop" workflow. The system empowers the user to act as the Architect—reviewing specifications, diagrams, and plans—while the AI acts as the Builder.

*   **1.2. Key Objectives:**
    *   **Transparency:** Visualize hidden AI state (Requirements, Architecture, Task Lists) via native VS Code UI elements.
    *   **Granular Control:** Enforce "Gating" mechanisms where the pipeline pauses for user approval at critical milestones.
    *   **Interactive Planning:** Transform static JSON task lists into interactive Tree Views allowing reordering and modification.
    *   **Iterative Review:** Implement a "Diff-Review" cycle for every generated code task, allowing users to Accept, Reject (with feedback), or Manually Fix code before proceeding.
    *   **Seamless Integration:** Operate within the user's existing editor environment, utilizing native Git and File System capabilities.

*   **1.3. Scope:**
    *   **In Scope:** The VS Code Extension (TypeScript), internal logic for spawning/managing the Python CLI process, File System watching/parsing, UI rendering (Webviews, TreeViews), and Git integration for diffs.
    *   **Out of Scope:** The internal logic of the `Type A` Python CLI itself (assumed to be an external dependency), modification of the VS Code core binary, and support for IDEs other than VS Code.

*   **1.4. Key Assumptions:**
    *   The user has a working Python environment with the target CLI dependencies installed.
    *   The target CLI supports (or will support) granular execution flags (e.g., `--step <id>`, `--pause-after-step`).
    *   The project workspace is initialized as a Git repository.
    *   File system events are reliable enough to trigger UI updates (Hot-reload).

## 2. Architectural Drivers

*   **2.1. Functional Requirements Summary:**
    *   Activity Bar "Control Center" with Phase, Task, and Artifact views.
    *   Interactive Prompting wizard generating `requirements.md`.
    *   Architecture visualization rendering embedded Mermaid diagrams.
    *   Task Board Tree View synchronized with `todo.json`.
    *   Step-by-step Build execution with Git Diff integration.
    *   Integrated QA status reporting.

*   **2.2. Non-Functional Requirements (NFRs):**
    *   **Responsiveness:** The UI must never freeze. CLI operations must run asynchronously in background processes.
    *   **State Persistence:** The system must be stateless in memory but stateful on disk; restarting VS Code should restore the exact progress from the `artifacts/` folder.
    *   **Idempotency:** Re-running a step or command should produce consistent results based on the current file state.
    *   **Usability:** Integration must feel native (using VS Code design tokens and standard views).

*   **2.3. Constraints & Preferences:**
    *   **Platform:** Visual Studio Code Extension API (Node.js runtime).
    *   **Backend:** Must interface with a specific Python CLI script (`cli.py`).
    *   **Communication:** Inter-process communication via `child_process` (stdin/stdout) and File System observation.

## 3. Proposed Architecture

*   **3.1. Architectural Style:**
    **Event-Driven Client-Wrapper (Local).**
    The architecture follows a local client-server model where the Extension acts as a "Thick Client" and the Python CLI acts as a stateless "Compute Engine." The system is heavily **Resource-Oriented**: the state of the application is defined entirely by the files on the disk (`artifacts/*.json`, `*.md`). The Extension observes these resources (File Watchers) to update the View, and spawns the CLI to mutate these resources.

*   **3.2. Technology Stack Summary:**

| Component | Technology | Justification |
| :--- | :--- | :--- |
| **Extension Runtime** | Node.js / TypeScript | Standard environment for VS Code Extensions. |
| **UI Framework** | React (in Webviews) & VS Code API | React for complex forms (Prompting); Native API for TreeViews and Status Bars to ensure performance and native look-and-feel. |
| **Backend Engine** | Python 3.x (CLI) | The existing `Type A` pipeline logic provided in requirements. |
| **State Storage** | File System (JSON / Markdown) | Ensures transparency and portability; allows user manual edits. |
| **Diagramming** | Mermaid.js | Lightweight, text-based diagramming supported natively by Markdown and easy to render in Webviews. |
| **Version Control** | Git | Essential for the "Diff-Review" feature; allows granular rollback of AI mistakes. |
| **Communication** | Node `child_process` | Standard method to spawn and control the Python CLI. |

*   **3.3. System Context Diagram (C4 Level 1):**
    *   **Description:** This diagram illustrates the Code Machine Orchestrator's position between the User, the VS Code Editor, and the underlying Python CLI/File System.

    ~~~plantuml
    @startuml
    !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml

    Person(architect, "Architect / Developer", "Reviews plans, approves steps, and provides feedback.")

    System_Boundary(vscode_env, "VS Code Environment") {
        System(extension, "Code Machine Orchestrator", "VS Code Extension. Manages the workflow, visualizes state, and controls the CLI.")
    }

    System(python_cli, "Type A Python CLI", "Generates code, plans, and artifacts based on prompts.")
    System(file_system, "File System / Git", "Stores project files, artifacts (JSON/MD), and version history.")

    Rel(architect, extension, "Interacts with", "GUI/Commands")
    Rel(extension, python_cli, "Spawns/Controls", "Shell Commands")
    Rel(extension, file_system, "Watches/Reads", "File API")
    Rel(extension, file_system, "Executes Git Ops", "Git CLI")
    Rel(python_cli, file_system, "Writes Artifacts & Code", "File I/O")
    Rel(file_system, extension, "Notifies changes", "File Events")

    @enduml
    ~~~

*   **3.4. Container Diagram (C4 Level 2):**
    *   **Description:** This details the internals of the Extension, separating the UI layer from the Logic layer and the external CLI process.

    ~~~plantuml
    @startuml
    !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

    System_Boundary(extension_boundary, "Code Machine Extension") {
        
        Container(ui_layer, "UI Components", "VS Code API / Webviews", "Sidebar, TreeView, Prompt Wizard, Diagram Preview.")
        
        Container(controller, "Workflow Controller", "TypeScript Class", "Orchestrates the state machine (Specs -> Arch -> Plan -> Build).")
        
        Container(cli_wrapper, "CLI Wrapper Service", "TypeScript / child_process", "Manages Python process lifecycle, parses stdout/stderr.")
        
        Container(fs_watcher, "State Monitor", "VS Code FileSystemWatcher", "Watches artifacts/ folder for changes to update UI.")
        
        Container(git_service, "Git Integration", "TypeScript / SimpleGit", "Handles commits, reverts, and diff staging.")
    }

    ContainerDb(artifacts, "Project Artifacts", "JSON / Markdown", "todo.json, requirements.md, architecture.md")
    Container(external_cli, "Python CLI Process", "Python", "Executes generation logic.")

    Rel(ui_layer, controller, "Sends User Actions")
    Rel(controller, ui_layer, "Updates View State")
    
    Rel(controller, cli_wrapper, "Triggers Commands")
    Rel(cli_wrapper, external_cli, "Spawns process", "Shell")
    
    Rel(controller, git_service, "Requests Diff/Revert")
    Rel(git_service, artifacts, "Git Operations")
    
    Rel(external_cli, artifacts, "Writes")
    Rel(fs_watcher, artifacts, "Observes")
    Rel(fs_watcher, controller, "Triggers Refresh")

    @enduml
    ~~~

*   **3.5. Component Diagram (C4 Level 3 - Workflow Controller):**
    *   **Description:** Details the `Workflow Controller` container, which is the brain of the extension, managing the complex state transitions and interactions between the user and the CLI.

    ~~~plantuml
    @startuml
    !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

    Container(controller_container, "Workflow Controller", "TypeScript", "Core Logic") {
        
        Component(state_machine, "Phase Manager", "State Pattern", "Tracks current phase (Specs, Arch, Build) and Gating logic.")
        Component(task_manager, "Task Orchestrator", "Module", "Parses todo.json, handles drag-and-drop logic, manages Task IDs.")
        Component(qa_handler, "QA Processor", "Module", "Parses test logs, updates task status badges.")
        Component(review_logic, "Diff Reviewer", "Module", "Manages the Accept/Reject/Retry loop and Git staging.")
    }

    Container(ui, "UI Layer", "VS Code Views")
    Container(cli, "CLI Wrapper", "Service")
    Container(git, "Git Service", "Service")

    Rel(ui, state_machine, "Approve Phase / Start Build")
    Rel(state_machine, cli, "Run CLI Command")
    
    Rel(ui, task_manager, "Reorder / Delete Task")
    Rel(task_manager, cli, "Run Specific Step")
    
    Rel(ui, review_logic, "Accept / Reject")
    Rel(review_logic, git, "Commit / Revert")
    Rel(review_logic, cli, "Retry with Feedback")

    Rel(cli, qa_handler, "Stream Logs")
    Rel(qa_handler, task_manager, "Update Task Status")

    @enduml
    ~~~

*   **3.6. Data Model Overview:**
    *   **Description:** The system relies on a file-based schema located in the `artifacts/` directory.
    *   **Key Files:**
        *   `requirements.md`: Markdown text.
        *   `architecture.md`: Markdown with embedded Mermaid code blocks.
        *   `todo.json`: Hierarchical JSON defining the build plan.
    *   **ERD (File Structure Representation):**

    ~~~plantuml
    @startuml
    package "artifacts/" {
        class "todo.json" as Todo {
            + iteration_id : string
            + tasks : List<Task>
        }

        class "Task" {
            + id : string
            + description : string
            + status : enum (pending, done, failed)
            + dependencies : List<string>
            + file_paths : List<string>
        }

        class "requirements.md" as Reqs {
            + content : markdown
        }

        class "architecture.md" as Arch {
            + content : markdown
            + diagrams : mermaid_string
        }
        
        class "logs/" as Logs {
            + task_id : string
            + content : text
        }
    }

    Todo *-- Task : contains
    Task --> Logs : generates
    @enduml
    ~~~

*   **3.7. API Design & Communication:**
    *   **Style:** Asynchronous Process Spawning (CLI) & File System Events.
    *   **Communication Pattern:**
        1.  **Command:** Extension spawns `python cli.py [args]`.
        2.  **Feedback:** Extension listens to `stdout` for progress bars/logs.
        3.  **Result:** Extension waits for `exit code 0` and file system changes.
    *   **Key Interaction Flow (The "Reject & Retry" Loop):**
        *   **Description:** The user rejects a generated task, providing feedback. The system reverts the code and instructs the CLI to try again.

    ~~~plantuml
    @startuml
    actor User
    participant "UI: Task Board" as UI
    participant "Controller" as Ctrl
    participant "Git Service" as Git
    participant "CLI Wrapper" as CLI
    participant "File System" as FS

    User -> UI : Clicks "Reject & Retry" (Input: "Fix error handling")
    UI -> Ctrl : handleReject(taskId, feedback)
    
    group Atomic Revert
        Ctrl -> Git : git reset --hard HEAD~1
        Git -> FS : Reverts files
        Git --> Ctrl : Success
    end

    Ctrl -> CLI : runStep(taskId, --feedback "Fix error handling")
    CLI -> FS : Spawns Python Process
    activate FS
    FS --> CLI : Process Writes Files
    deactivate FS
    CLI --> Ctrl : Exit Code 0
    
    Ctrl -> Git : git add . && git commit -m "Retry Task..."
    Ctrl -> UI : Update Diff View (New Changes)
    UI -> User : Shows new Diff
    @enduml
    ~~~

*   **3.8. Cross-Cutting Concerns:**
    *   **Authentication:** N/A (Local tool). Relies on user's local file system permissions.
    *   **Logging:**
        *   **Extension Logs:** Written to VS Code Output Channel ("Code Machine").
        *   **CLI Logs:** Captured from stdout/stderr and written to `artifacts/logs/<task_id>.log` for QA parsing.
    *   **Security:**
        *   **Execution:** CLI commands are executed in the user's shell context.
        *   **Input Sanitization:** User prompts and feedback strings must be escaped before being passed as shell arguments to prevent injection.
    *   **Scalability:**
        *   **Large Projects:** `todo.json` parsing must be optimized for large trees (virtualized rendering in UI).
    *   **Reliability:**
        *   **Process Management:** Orphaned Python processes must be killed if VS Code closes.
        *   **File Watching:** Debounce logic required to prevent UI flickering during rapid file writes.

*   **3.9. Deployment View:**
    *   **Target Environment:** User's Local Machine (Windows, macOS, Linux).
    *   **Strategy:** Distributed via VS Code Marketplace (`.vsix`).
    *   **Dependencies:** Requires Python 3.x installed on the host machine.

## 4. Design Rationale & Trade-offs

*   **4.1. Key Decisions Summary:**
    *   **File-Based State:** We chose to use the file system (`artifacts/`) as the "Source of Truth" rather than an internal database.
        *   *Rationale:* Allows the user to edit the plan or requirements manually using standard text editors without breaking the extension's state. It aligns with the "Transparency" objective.
    *   **Granular CLI Execution:** The CLI is invoked per-task rather than as a long-running daemon.
        *   *Rationale:* Simplifies error handling and state management. If the CLI crashes, it doesn't crash the Extension. It enables the "Pause/Resume" functionality natively.
    *   **Git for Diffing:** Leveraging the existing Git repository rather than a custom diff engine.
        *   *Rationale:* Developers trust Git. It allows the "Reject" feature to be implemented simply as `git reset`.

*   **4.2. Alternatives Considered:**
    *   *Long-running Python Server (Flask/FastAPI):*
        *   *Rejected:* Adds complexity (port management, firewall issues). Spawning processes is simpler for a local tool.
    *   *Webview-only UI:*
        *   *Rejected:* Using native VS Code TreeViews for the Task Board provides better performance and integration with the editor's theme/shortcuts than a full HTML/React implementation.

*   **4.3. Known Risks & Mitigation:**
    *   *Risk:* CLI execution blocks the UI.
        *   *Mitigation:* Strict usage of `async/await` and Worker threads for all `child_process` interactions.
    *   *Risk:* User modifies `todo.json` with invalid syntax manually.
        *   *Mitigation:* JSON Schema validation in the Extension. If parsing fails, show a friendly error and disable the "Build" button.

## 5. Future Considerations

*   **5.1. Potential Evolution:**
    *   **Remote Execution:** Allow the CLI to run in a Docker container or remote server (SSH) while the UI remains local.
    *   **Multi-Agent Visualization:** If the CLI evolves to use multiple agents, the UI could visualize agent-to-agent chat logs.

*   **5.2. Areas for Deeper Dive:**
    *   **Diff View UX:** The specific API usage for opening the VS Code Diff Editor programmatically with a specific commit range needs prototyping.
    *   **Terminal Output Parsing:** Robust Regex patterns are needed to parse the CLI's stdout for progress bars and QA results reliably.

## 6. Glossary

*   **CLI:** Command Line Interface (The Python script).
*   **Artifacts:** Intermediate files generated by the AI (Requirements, Architecture, Plan).
*   **Gating:** The architectural pattern of stopping a process to await human approval.
*   **Hot-reload:** Automatically updating the UI when underlying data files change.
*   **Webview:** A VS Code mechanism to render arbitrary HTML/JS within an editor panel.