[
    {
        "name": "I1.T1",
        "context": {
            "task_id": "I1.T1",
            "iteration_id": "I1",
            "iteration_goal": "Initialize the project, set up the extension manifest, implement the core CLI wrapper service, and define the high-level architecture.",
            "description": "Initialize VS Code Extension project structure using `yo code` (or manual setup) with TypeScript. Configure `package.json` with basic activation events and the \"Code Machine\" output channel.",
            "agent_type_hint": "SetupAgent",
            "inputs": "Project Name \"Code Machine Orchestrator\".",
            "target_files": [
                "package.json",
                "src/extension.ts",
                "tsconfig.json"
            ],
            "input_files": [],
            "deliverables": "Initialized project repository.",
            "acceptance_criteria": "Extension compiles and runs in \"Extension Development Host\". \"Code Machine\" output channel is visible.",
            "dependencies": [],
            "parallelizable": false
        },
        "output": "This is the first step in building the \"Code Machine Orchestrator\" VS Code extension. My task is to initialize the project structure by creating the essential configuration and entry-point files. I will create `package.json` to define the extension's manifest, `tsconfig.json` for TypeScript compilation settings, and `src/extension.ts` for the activation logic, which includes creating and showing the \"Code Machine\" output channel as required by the acceptance criteria.\n\n~~~json\n#- file: package.json\n{\n  \"name\": \"code-machine-orchestrator\",\n  \"displayName\": \"Code Machine Orchestrator\",\n  \"description\": \"A VS Code extension to orchestrate a requirements-to-code CLI pipeline.\",\n  \"version\": \"0.0.1\",\n  \"engines\": {\n    \"vscode\": \"^1.84.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onStartupFinished\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {},\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.84.0\",\n    \"@types/mocha\": \"^10.0.3\",\n    \"@types/node\": \"18.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.9.0\",\n    \"@typescript-eslint/parser\": \"^6.9.0\",\n    \"eslint\": \"^8.52.0\",\n    \"glob\": \"^10.3.10\",\n    \"mocha\": \"^10.2.0\",\n    \"typescript\": \"^5.2.2\",\n    \"@vscode/test-electron\": \"^2.3.6\"\n  }\n}\n~~~\n~~~typescript\n#- file: src/extension.ts\nimport * as vscode from 'vscode';\n\nexport function activate(context: vscode.ExtensionContext) {\n\n\tconsole.log('Congratulations, your extension \"code-machine-orchestrator\" is now active!');\n\n\tconst outputChannel = vscode.window.createOutputChannel('Code Machine');\n\toutputChannel.appendLine('Code Machine Orchestrator activated.');\n\toutputChannel.show(true);\n\n\tcontext.subscriptions.push(outputChannel);\n}\n\nexport function deactivate() {}\n~~~\n~~~json\n#- file: tsconfig.json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es2020\",\n    \"outDir\": \"out\",\n    \"lib\": [\n      \"es2020\"\n    ],\n    \"sourceMap\": true,\n    \"rootDir\": \"src\",\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"skipLibCheck\": true\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \".vscode-test\"\n  ]\n}\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "package.json",
            "src/extension.ts",
            "tsconfig.json"
        ],
        "input_files": [],
        "files": [
            {
                "path": "tsconfig.json",
                "content": "{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es2020\",\n    \"outDir\": \"out\",\n    \"lib\": [\n      \"es2020\"\n    ],\n    \"sourceMap\": true,\n    \"rootDir\": \"src\",\n    \"strict\": true,\n    \"moduleResolution\": \"node\"\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \".vscode-test\"\n  ]\n}"
            },
            {
                "path": "src/extension.ts",
                "content": "import * as vscode from 'vscode';\n\nexport function activate(context: vscode.ExtensionContext) {\n\tconsole.log('The \"Code Machine Orchestrator\" extension is now active.');\n\n\tconst outputChannel = vscode.window.createOutputChannel('Code Machine');\n\toutputChannel.appendLine('Code Machine Orchestrator activated.');\n\toutputChannel.show(true); // Passing true preserves focus on the editor\n\n\tcontext.subscriptions.push(outputChannel);\n}\n\nexport function deactivate() {}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"code-machine-orchestrator\",\n  \"displayName\": \"Code Machine Orchestrator\",\n  \"description\": \"A VS Code extension to orchestrate a requirements-to-code CLI pipeline.\",\n  \"version\": \"0.0.1\",\n  \"engines\": {\n    \"vscode\": \"^1.84.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"*\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {},\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.84.0\",\n    \"@types/mocha\": \"^10.0.3\",\n    \"@types/node\": \"18.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.9.0\",\n    \"@typescript-eslint/parser\": \"^6.9.0\",\n    \"eslint\": \"^8.52.0\",\n    \"glob\": \"^10.3.10\",\n    \"mocha\": \"^10.2.0\",\n    \"typescript\": \"^5.2.2\",\n    \"@vscode/test-electron\": \"^2.3.6\"\n  }\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"code-machine-orchestrator\",\n  \"displayName\": \"Code Machine Orchestrator\",\n  \"description\": \"A VS Code extension to orchestrate a requirements-to-code CLI pipeline.\",\n  \"version\": \"0.0.1\",\n  \"engines\": {\n    \"vscode\": \"^1.84.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onStartupFinished\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {},\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.84.0\",\n    \"@types/mocha\": \"^10.0.3\",\n    \"@types/node\": \"18.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.9.0\",\n    \"@typescript-eslint/parser\": \"^6.9.0\",\n    \"eslint\": \"^8.52.0\",\n    \"glob\": \"^10.3.10\",\n    \"mocha\": \"^10.2.0\",\n    \"typescript\": \"^5.2.2\",\n    \"@vscode/test-electron\": \"^2.3.6\"\n  }\n}"
            },
            {
                "path": "tsconfig.json",
                "content": "{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es2020\",\n    \"outDir\": \"out\",\n    \"lib\": [\n      \"es2020\"\n    ],\n    \"sourceMap\": true,\n    \"rootDir\": \"src\",\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"skipLibCheck\": true\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \".vscode-test\"\n  ]\n}"
            },
            {
                "path": "src/extension.ts",
                "content": "import * as vscode from 'vscode';\n\nexport function activate(context: vscode.ExtensionContext) {\n\tconsole.log('The \"Code Machine Orchestrator\" extension is now active.');\n\n\tconst outputChannel = vscode.window.createOutputChannel('Code Machine');\n\toutputChannel.appendLine('Code Machine Orchestrator activated.');\n\toutputChannel.show(true); // Passing true preserves focus on the editor\n\n\tcontext.subscriptions.push(outputChannel);\n}\n\nexport function deactivate() {}"
            },
            {
                "path": "tsconfig.json",
                "content": "{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es2020\",\n    \"outDir\": \"out\",\n    \"lib\": [\n      \"es2020\"\n    ],\n    \"sourceMap\": true,\n    \"rootDir\": \"src\",\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"skipLibCheck\": true\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \".vscode-test\"\n  ]\n}"
            },
            {
                "path": "src/extension.ts",
                "content": "import * as vscode from 'vscode'\n\nexport function activate(context: vscode.ExtensionContext) {\n\tconsole.log('The \"Code Machine Orchestrator\" extension is now active.')\n\n\tconst outputChannel = vscode.window.createOutputChannel('Code Machine')\n\toutputChannel.appendLine('Code Machine Orchestrator activated.')\n\toutputChannel.show(true) // Passing true preserves focus on the editor\n\n\tcontext.subscriptions.push(outputChannel)\n}\n\nexport function deactivate() {}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"code-machine-orchestrator\",\n  \"displayName\": \"Code Machine Orchestrator\",\n  \"description\": \"A VS Code extension to orchestrate a requirements-to-code CLI pipeline.\",\n  \"version\": \"0.0.1\",\n  \"engines\": {\n    \"vscode\": \"^1.84.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onStartupFinished\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {},\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.84.0\",\n    \"@types/mocha\": \"^10.0.3\",\n    \"@types/node\": \"18.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.9.0\",\n    \"@typescript-eslint/parser\": \"^6.9.0\",\n    \"eslint\": \"^8.52.0\",\n    \"glob\": \"^10.3.10\",\n    \"mocha\": \"^10.2.0\",\n    \"typescript\": \"^5.2.2\",\n    \"@vscode/test-electron\": \"^2.3.6\"\n  }\n}"
            },
            {
                "path": "tsconfig.json",
                "content": "{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"es2020\",\n    \"outDir\": \"out\",\n    \"lib\": [\n      \"es2020\"\n    ],\n    \"sourceMap\": true,\n    \"rootDir\": \"src\",\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"skipLibCheck\": true\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \".vscode-test\"\n  ]\n}"
            },
            {
                "path": "src/extension.ts",
                "content": "import * as vscode from 'vscode';\n\nexport function activate(context: vscode.ExtensionContext) {\n\n\tconsole.log('Congratulations, your extension \"code-machine-orchestrator\" is now active!');\n\n\tconst outputChannel = vscode.window.createOutputChannel('Code Machine');\n\toutputChannel.appendLine('Code Machine Orchestrator activated.');\n\toutputChannel.show(true);\n\n\tcontext.subscriptions.push(outputChannel);\n}\n\nexport function deactivate() {}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"code-machine-orchestrator\",\n  \"displayName\": \"Code Machine Orchestrator\",\n  \"description\": \"A VS Code extension to orchestrate a requirements-to-code CLI pipeline.\",\n  \"version\": \"0.0.1\",\n  \"engines\": {\n    \"vscode\": \"^1.84.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onStartupFinished\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {},\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.84.0\",\n    \"@types/mocha\": \"^10.0.3\",\n    \"@types/node\": \"18.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.9.0\",\n    \"@typescript-eslint/parser\": \"^6.9.0\",\n    \"eslint\": \"^8.52.0\",\n    \"glob\": \"^10.3.10\",\n    \"mocha\": \"^10.2.0\",\n    \"typescript\": \"^5.2.2\",\n    \"@vscode/test-electron\": \"^2.3.6\"\n  }\n}"
            }
        ]
    },
    {
        "name": "I1.T2",
        "context": {
            "task_id": "I1.T2",
            "iteration_id": "I1",
            "iteration_goal": "Initialize the project, set up the extension manifest, implement the core CLI wrapper service, and define the high-level architecture.",
            "description": "Generate a System Component Diagram showing the Extension, Workflow Controller, CLI Wrapper, and File System interactions.",
            "agent_type_hint": "DiagrammingAgent",
            "inputs": "Section 2 (Core Architecture).",
            "target_files": [
                "docs/diagrams/system_component.puml"
            ],
            "input_files": [],
            "deliverables": "PlantUML diagram file.",
            "acceptance_criteria": "Diagram clearly separates UI, Logic, and External CLI. Renders without syntax errors.",
            "dependencies": [],
            "parallelizable": true
        },
        "output": "~~~\n#- file: docs/diagrams/system_component.puml\n@startuml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml\n\ntitle System Component Diagram for Code Machine Orchestrator\n\nSystem_Boundary(extension_boundary, \"Code Machine Extension\") {\n    \n    Container(ui_layer, \"UI Components\", \"VS Code API / Webviews\", \"Sidebar, TreeView, Prompt Wizard, Diagram Preview.\")\n    \n    Container(controller, \"Workflow Controller\", \"TypeScript Class\", \"Orchestrates the state machine (Specs -> Arch -> Plan -> Build).\")\n    \n    Container(cli_wrapper, \"CLI Wrapper Service\", \"TypeScript / child_process\", \"Manages Python process lifecycle, parses stdout/stderr.\")\n    \n    Container(fs_watcher, \"State Monitor\", \"VS Code FileSystemWatcher\", \"Watches artifacts/ folder for changes to update UI.\")\n    \n    Container(git_service, \"Git Integration\", \"TypeScript / SimpleGit\", \"Handles commits, reverts, and diff staging.\")\n}\n\nContainerDb(artifacts, \"Project Artifacts\", \"JSON / Markdown\", \"todo.json, requirements.md, architecture.md\")\nContainer(external_cli, \"Python CLI Process\", \"Python\", \"Executes generation logic.\")\n\nRel(ui_layer, controller, \"Sends User Actions\")\nRel(controller, ui_layer, \"Updates View State\")\n\nRel(controller, cli_wrapper, \"Triggers Commands\")\nRel(cli_wrapper, external_cli, \"Spawns process\", \"Shell\")\n\nRel(controller, git_service, \"Requests Diff/Revert\")\nRel(git_service, artifacts, \"Git Operations\")\n\nRel(external_cli, artifacts, \"Writes\")\nRel(fs_watcher, artifacts, \"Observes\")\nRel(fs_watcher, controller, \"Triggers Refresh\")\n\n@enduml\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "docs/diagrams/system_component.puml"
        ],
        "input_files": [],
        "files": [
            {
                "path": "docs/diagrams/system_component.puml",
                "content": "@startuml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml\n\ntitle System Component Diagram for Code Machine Orchestrator\n\nSystem_Boundary(extension_boundary, \"Code Machine Extension\") {\n    \n    Container(ui_layer, \"UI Components\", \"VS Code API / Webviews\", \"Sidebar, TreeView, Prompt Wizard, Diagram Preview.\")\n    \n    Container(controller, \"Workflow Controller\", \"TypeScript Class\", \"Orchestrates the state machine (Specs -> Arch -> Plan -> Build).\")\n    \n    Container(cli_wrapper, \"CLI Wrapper Service\", \"TypeScript / child_process\", \"Manages Python process lifecycle, parses stdout/stderr.\")\n    \n    Container(fs_watcher, \"State Monitor\", \"VS Code FileSystemWatcher\", \"Watches artifacts/ folder for changes to update UI.\")\n    \n    Container(git_service, \"Git Integration\", \"TypeScript / SimpleGit\", \"Handles commits, reverts, and diff staging.\")\n}\n\nContainerDb(artifacts, \"Project Artifacts\", \"JSON / Markdown\", \"todo.json, requirements.md, architecture.md\")\nContainer(external_cli, \"Python CLI Process\", \"Python\", \"Executes generation logic.\")\n\nRel(ui_layer, controller, \"Sends User Actions\")\nRel(controller, ui_layer, \"Updates View State\")\n\nRel(controller, cli_wrapper, \"Triggers Commands\")\nRel(cli_wrapper, external_cli, \"Spawns process\", \"Shell\")\n\nRel(controller, git_service, \"Requests Diff/Revert\")\nRel(git_service, artifacts, \"Git Operations\")\n\nRel(external_cli, artifacts, \"Writes\")\nRel(fs_watcher, artifacts, \"Observes\")\nRel(fs_watcher, controller, \"Triggers Refresh\")\n\n@enduml"
            }
        ]
    },
    {
        "name": "I1.T3",
        "context": {
            "task_id": "I1.T3",
            "iteration_id": "I1",
            "iteration_goal": "Initialize the project, set up the extension manifest, implement the core CLI wrapper service, and define the high-level architecture.",
            "description": "Implement `CliService`. This class should handle spawning a child process, returning a Promise that resolves on exit code 0, and streaming stdout to the Output Channel. Include a `MockCli.py` in `test/mocks` that accepts arguments and sleeps/prints to simulate work.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Requirement 5.4 (CLI Integration Wrapper).",
            "target_files": [
                "src/services/CliService.ts",
                "test/mocks/mock_cli.py"
            ],
            "input_files": [
                "src/extension.ts"
            ],
            "deliverables": "TypeScript service class and Python mock script.",
            "acceptance_criteria": "Unit test confirms `CliService` can run `mock_cli.py` and capture output.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": false
        },
        "output": "~~~\n#- file: src/services/CliService.ts\nimport * as vscode from 'vscode';\nimport { spawn } from 'child_process';\n\nexport class CliService {\n    /**\n     * Executes a command-line tool.\n     * \n     * @param command The command to execute (e.g., 'python').\n     * @param args An array of string arguments.\n     * @param outputChannel The VS Code output channel to stream stdout and stderr to.\n     * @returns A promise that resolves if the command exits with code 0, and rejects otherwise.\n     */\n    public execute(command: string, args: string[], outputChannel: vscode.OutputChannel): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            outputChannel.appendLine(`> Running command: ${command} ${args.join(' ')}`);\n\n            const child = spawn(command, args);\n\n            // Stream stdout\n            if (child.stdout) {\n                child.stdout.on('data', (data: Buffer) => {\n                    outputChannel.append(data.toString());\n                });\n            }\n\n            // Stream stderr\n            if (child.stderr) {\n                child.stderr.on('data', (data: Buffer) => {\n                    outputChannel.append(data.toString());\n                });\n            }\n\n            // Handle spawn errors (e.g., command not found)\n            child.on('error', (error) => {\n                outputChannel.appendLine(`Error spawning process: ${error.message}`);\n                reject(error);\n            });\n\n            // Handle process exit\n            child.on('close', (code) => {\n                if (code === 0) {\n                    outputChannel.appendLine(`> Command finished with exit code ${code}.`);\n                    resolve();\n                } else {\n                    const errorMessage = `Command failed with exit code ${code}.`;\n                    outputChannel.appendLine(`> ${errorMessage}`);\n                    reject(new Error(errorMessage));\n                }\n            });\n        });\n    }\n}\n~~~\n~~~\n#- file: test/mocks/mock_cli.py\nimport sys\nimport time\n\ndef main():\n    \"\"\"\n    A mock CLI tool that simulates a long-running process.\n    It prints arguments, shows progress, and then exits.\n    \"\"\"\n    print(\"MockCli: Process started.\")\n    print(f\"MockCli: Received arguments: {sys.argv[1:]}\")\n    sys.stdout.flush()\n\n    num_steps = 3\n    for i in range(1, num_steps + 1):\n        print(f\"MockCli: Processing step {i} of {num_steps}...\")\n        sys.stdout.flush()\n        time.sleep(0.5)  # Simulate work for 0.5 seconds\n\n    print(\"MockCli: Process completed successfully.\")\n    sys.stdout.flush()\n    sys.exit(0)\n\nif __name__ == \"__main__\":\n    main()\n~~~",
        "iteration_id": "I1",
        "completed": true,
        "target_files": [
            "src/services/CliService.ts",
            "test/mocks/mock_cli.py"
        ],
        "input_files": [
            "src/extension.ts"
        ],
        "files": [
            {
                "path": "src/extension.ts",
                "content": "import * as vscode from 'vscode';\n\nexport function activate(context: vscode.ExtensionContext) {\n\n\tconsole.log('Congratulations, your extension \"code-machine-orchestrator\" is now active!');\n\n\tconst outputChannel = vscode.window.createOutputChannel('Code Machine');\n\toutputChannel.appendLine('Code Machine Orchestrator activated.');\n\toutputChannel.show(true);\n\n\tcontext.subscriptions.push(outputChannel);\n}\n\nexport function deactivate() {}"
            },
            {
                "path": "test/mocks/mock_cli.py",
                "content": "import sys\nimport time\n\ndef main():\n    \"\"\"\n    A mock CLI tool that simulates a long-running process.\n    It prints arguments, shows progress, and then exits.\n    \"\"\"\n    print(\"MockCli: Process started.\")\n    print(f\"MockCli: Received arguments: {sys.argv[1:]}\")\n    sys.stdout.flush()\n\n    num_steps = 3\n    for i in range(1, num_steps + 1):\n        print(f\"MockCli: Processing step {i} of {num_steps}...\")\n        sys.stdout.flush()\n        time.sleep(0.5)  # Simulate work for 0.5 seconds\n\n    print(\"MockCli: Process completed successfully.\")\n    sys.stdout.flush()\n    sys.exit(0)\n\nif __name__ == \"__main__\":\n    main()"
            },
            {
                "path": "src/services/CliService.ts",
                "content": "import * as vscode from 'vscode';\nimport { spawn } from 'child_process';\n\nexport class CliService {\n    /**\n     * Executes a command-line tool.\n     * \n     * @param command The command to execute (e.g., 'python').\n     * @param args An array of string arguments.\n     * @param outputChannel The VS Code output channel to stream stdout and stderr to.\n     * @returns A promise that resolves if the command exits with code 0, and rejects otherwise.\n     */\n    public execute(command: string, args: string[], outputChannel: vscode.OutputChannel): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            outputChannel.appendLine(`> Running command: ${command} ${args.join(' ')}`);\n\n            const child = spawn(command, args);\n\n            // Stream stdout\n            if (child.stdout) {\n                child.stdout.on('data', (data: Buffer) => {\n                    outputChannel.append(data.toString());\n                });\n            }\n\n            // Stream stderr\n            if (child.stderr) {\n                child.stderr.on('data', (data: Buffer) => {\n                    outputChannel.append(data.toString());\n                });\n            }\n\n            // Handle spawn errors (e.g., command not found)\n            child.on('error', (error) => {\n                outputChannel.appendLine(`Error spawning process: ${error.message}`);\n                reject(error);\n            });\n\n            // Handle process exit\n            child.on('close', (code) => {\n                if (code === 0) {\n                    outputChannel.appendLine(`> Command finished with exit code ${code}.`);\n                    resolve();\n                } else {\n                    const errorMessage = `Command failed with exit code ${code}.`;\n                    outputChannel.appendLine(`> ${errorMessage}`);\n                    reject(new Error(errorMessage));\n                }\n            });\n        });\n    }\n}"
            },
            {
                "path": "src/extension.ts",
                "content": "import * as vscode from 'vscode';\n\nexport function activate(context: vscode.ExtensionContext) {\n\n\tconsole.log('Congratulations, your extension \"code-machine-orchestrator\" is now active!');\n\n\tconst outputChannel = vscode.window.createOutputChannel('Code Machine');\n\toutputChannel.appendLine('Code Machine Orchestrator activated.');\n\toutputChannel.show(true);\n\n\tcontext.subscriptions.push(outputChannel);\n}\n\nexport function deactivate() {}"
            },
            {
                "path": "test/mocks/mock_cli.py",
                "content": "import sys\nimport time\n\ndef main():\n    \"\"\"\n    A mock CLI tool that simulates a long-running process.\n    It prints arguments, shows progress, and then exits.\n    Can be made to fail by passing the '--fail' argument.\n    \"\"\"\n    print(\"MockCli: Process started.\")\n    args = sys.argv[1:]\n    print(f\"MockCli: Received arguments: {args}\")\n    sys.stdout.flush()\n\n    if '--fail' in args:\n        print(\"MockCli: Simulating failure.\")\n        sys.stderr.write(\"This is an error message.\\n\")\n        sys.stdout.flush()\n        sys.stderr.flush()\n        sys.exit(1)\n\n    num_steps = 3\n    for i in range(1, num_steps + 1):\n        print(f\"MockCli: Processing step {i} of {num_steps}...\")\n        sys.stdout.flush()\n        time.sleep(0.1)  # Simulate work for 0.1 seconds for faster tests\n\n    print(\"MockCli: Process completed successfully.\")\n    sys.stdout.flush()\n    sys.exit(0)\n\nif __name__ == \"__main__\":\n    main()"
            },
            {
                "path": "src/services/CliService.ts",
                "content": "import * as vscode from 'vscode';\nimport { spawn } from 'child_process';\n\nexport class CliService {\n    /**\n     * Executes a command-line tool.\n     * \n     * @param command The command to execute (e.g., 'python').\n     * @param args An array of string arguments.\n     * @param outputChannel The VS Code output channel to stream stdout and stderr to.\n     * @returns A promise that resolves if the command exits with code 0, and rejects otherwise.\n     */\n    public execute(command: string, args: string[], outputChannel: vscode.OutputChannel): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            outputChannel.appendLine(`> Running command: ${command} ${args.join(' ')}`);\n\n            const child = spawn(command, args);\n\n            // Stream stdout\n            if (child.stdout) {\n                child.stdout.on('data', (data: Buffer) => {\n                    outputChannel.append(data.toString());\n                });\n            }\n\n            // Stream stderr\n            if (child.stderr) {\n                child.stderr.on('data', (data: Buffer) => {\n                    outputChannel.append(data.toString());\n                });\n            }\n\n            // Handle spawn errors (e.g., command not found)\n            child.on('error', (error) => {\n                outputChannel.appendLine(`Error spawning process: ${error.message}`);\n                reject(error);\n            });\n\n            // Handle process exit\n            child.on('close', (code) => {\n                if (code === 0) {\n                    outputChannel.appendLine(`> Command finished with exit code ${code}.`);\n                    resolve();\n                } else {\n                    const errorMessage = `Command failed with exit code ${code}.`;\n                    outputChannel.appendLine(`> ${errorMessage}`);\n                    reject(new Error(errorMessage));\n                }\n            });\n        });\n    }\n}"
            },
            {
                "path": "src/extension.ts",
                "content": "import * as vscode from 'vscode';\n\nexport function activate(context: vscode.ExtensionContext) {\n\n\tconsole.log('Congratulations, your extension \"code-machine-orchestrator\" is now active!');\n\n\tconst outputChannel = vscode.window.createOutputChannel('Code Machine');\n\toutputChannel.appendLine('Code Machine Orchestrator activated.');\n\toutputChannel.show(true);\n\n\tcontext.subscriptions.push(outputChannel);\n}\n\nexport function deactivate() {}"
            }
        ]
    },
    {
        "name": "I2.T1",
        "context": {
            "task_id": "I2.T1",
            "iteration_id": "I2",
            "iteration_goal": "Implement the Activity Bar container, the Sidebar layout, and the State Machine logic to track the project phase.",
            "description": "Generate a State Machine Diagram defining transitions: Concept -> Specs -> Arch -> Plan -> Build. Define triggers (e.g., \"Approve Specs\").",
            "agent_type_hint": "DiagrammingAgent",
            "inputs": "Requirement 3.1 (Project State).",
            "target_files": [
                "docs/diagrams/workflow_state.mmd"
            ],
            "input_files": [],
            "deliverables": "Mermaid diagram file.",
            "acceptance_criteria": "Covers all 5 phases and \"Gating\" transitions.",
            "dependencies": [],
            "parallelizable": true
        },
        "output": "I will now execute the plan to create the state machine diagram.\n\nThe task is to generate a Mermaid state machine diagram in the file `docs/diagrams/workflow_state.mmd`. This diagram must illustrate the five project phases (Concept, Specs, Arch, Plan, Build) and the \"Gating\" transitions between them, as specified in the requirements.\n\nI will create a new file with the following Mermaid syntax:\n1.  Initialize a `stateDiagram-v2`.\n2.  Define the start state `[*]` transitioning to `Concept`.\n3.  Define each of the five states in sequence: `Concept`, `Specs`, `Arch`, `Plan`, `Build`.\n4.  Create directed transitions between each state, labeling them with the appropriate \"Gating\" action (e.g., \"Approve & Lock Specs\").\n5.  Define the final transition from `Build` to the end state `[*]`.\n\nThis will fulfill all the requirements and acceptance criteria for task I2.T1.\n\n~~~\n#- file: docs/diagrams/workflow_state.mmd\nstateDiagram-v2\n    direction LR\n\n    [*] --> Concept: Start New Project\n\n    Concept --> Specs: Generate Specs\n    Specs --> Arch: Approve & Lock Specs\n    Arch --> Plan: Approve Architecture\n    Plan --> Build: Approve Plan\n    Build --> [*]: Finish\n\n~~~",
        "iteration_id": "I2",
        "completed": true,
        "target_files": [
            "docs/diagrams/workflow_state.mmd"
        ],
        "input_files": [],
        "files": [
            {
                "path": "docs/diagrams/workflow_state.mmd",
                "content": "stateDiagram-v2\n    direction LR\n\n    [*] --> Concept: Start New Project\n\n    Concept --> Specs: Generate Specs\n    Specs --> Arch: Approve & Lock Specs\n    Arch --> Plan: Approve Architecture\n    Plan --> Build: Approve Plan\n    Build --> [*]: Finish"
            }
        ]
    },
    {
        "name": "I2.T2",
        "context": {
            "task_id": "I2.T2",
            "iteration_id": "I2",
            "iteration_goal": "Implement the Activity Bar container, the Sidebar layout, and the State Machine logic to track the project phase.",
            "description": "Update `package.json` to contribute a View Container (Activity Bar) and three Views (Project State, Task Board, Artifacts). Implement a basic `WorkflowController` that holds the current phase state.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Requirement 3.1.",
            "target_files": [
                "package.json",
                "src/controllers/WorkflowController.ts"
            ],
            "input_files": [
                "package.json",
                "docs/diagrams/workflow_state.mmd"
            ],
            "deliverables": "Updated manifest and controller logic.",
            "acceptance_criteria": "The \"Code Machine\" icon appears in the sidebar. Three empty views are visible.",
            "dependencies": [
                "I1.T1"
            ],
            "parallelizable": false
        },
        "output": "Okay, I'm ready to proceed with task I2.T2. Here is my plan:\n\n1.  **Analyze `package.json`:** I will update the `contributes` section to declare a new view container for the activity bar and three associated views: \"Project State,\" \"Task Board,\" and \"Artifacts.\" This will make the \"Code Machine\" icon and its sidebar panel visible in VS Code, fulfilling a key acceptance criterion.\n\n2.  **Analyze `src/controllers/WorkflowController.ts`:** I will create a new controller file to manage the project's state.\n    *   I will define a `Phase` enum based on the states in `docs/diagrams/workflow_state.mmd` (Concept, Specs, Arch, Plan, Build).\n    *   I will implement the `WorkflowController` class, which will hold the current phase, initialized to `Phase.Concept`. This class will serve as the single source of truth for the project's workflow state.\n\nI will now generate the required file content.\n\n~~~json\n#- file: package.json\n{\n  \"name\": \"code-machine-orchestrator\",\n  \"displayName\": \"Code Machine Orchestrator\",\n  \"description\": \"A VS Code extension to orchestrate a requirements-to-code CLI pipeline.\",\n  \"publisher\": \"CodeMachine\",\n  \"version\": \"0.0.1\",\n  \"engines\": {\n    \"vscode\": \"^1.84.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onStartupFinished\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"code-machine-container\",\n          \"title\": \"Code Machine\",\n          \"icon\": \"$(beaker)\"\n        }\n      ]\n    },\n    \"views\": {\n      \"code-machine-container\": [\n        {\n          \"id\": \"codeMachine.projectState\",\n          \"name\": \"Project State\"\n        },\n        {\n          \"id\": \"codeMachine.taskBoard\",\n          \"name\": \"Task Board\"\n        },\n        {\n          \"id\": \"codeMachine.artifacts\",\n          \"name\": \"Artifacts\"\n        }\n      ]\n    }\n  },\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.84.0\",\n    \"@types/mocha\": \"^10.0.6\",\n    \"@types/node\": \"18.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.9.0\",\n    \"@typescript-eslint/parser\": \"^6.9.0\",\n    \"eslint\": \"^8.52.0\",\n    \"glob\": \"^10.3.10\",\n    \"mocha\": \"^10.2.0\",\n    \"typescript\": \"^5.2.2\",\n    \"@vscode/test-electron\": \"^2.3.6\"\n  }\n}\n~~~\n~~~typescript\n#- file: src/controllers/WorkflowController.ts\nexport enum Phase {\n    Concept,\n    Specs,\n    Arch,\n    Plan,\n    Build\n}\n\nexport class WorkflowController {\n    private _currentPhase: Phase;\n\n    constructor() {\n        this._currentPhase = Phase.Concept;\n    }\n\n    public get currentPhase(): Phase {\n        return this._currentPhase;\n    }\n}\n~~~",
        "iteration_id": "I2",
        "completed": true,
        "target_files": [
            "package.json",
            "src/controllers/WorkflowController.ts"
        ],
        "input_files": [
            "package.json",
            "docs/diagrams/workflow_state.mmd"
        ],
        "files": [
            {
                "path": "docs/diagrams/workflow_state.mmd",
                "content": "stateDiagram-v2\n    direction LR\n\n    [*] --> Concept: Start New Project\n\n    Concept --> Specs: Generate Specs\n    Specs --> Arch: Approve & Lock Specs\n    Arch --> Plan: Approve Architecture\n    Plan --> Build: Approve Plan\n    Build --> [*]: Finish"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"code-machine-orchestrator\",\n  \"displayName\": \"Code Machine Orchestrator\",\n  \"description\": \"A VS Code extension to orchestrate a requirements-to-code CLI pipeline.\",\n  \"publisher\": \"CodeMachine\",\n  \"version\": \"0.0.1\",\n  \"engines\": {\n    \"vscode\": \"^1.84.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onStartupFinished\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {},\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.84.0\",\n    \"@types/mocha\": \"^10.0.3\",\n    \"@types/node\": \"18.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.9.0\",\n    \"@typescript-eslint/parser\": \"^6.9.0\",\n    \"eslint\": \"^8.52.0\",\n    \"glob\": \"^10.3.10\",\n    \"mocha\": \"^10.2.0\",\n    \"typescript\": \"^5.2.2\",\n    \"@vscode/test-electron\": \"^2.3.6\"\n  }\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"code-machine-orchestrator\",\n  \"displayName\": \"Code Machine Orchestrator\",\n  \"description\": \"A VS Code extension to orchestrate a requirements-to-code CLI pipeline.\",\n  \"publisher\": \"CodeMachine\",\n  \"version\": \"0.0.1\",\n  \"engines\": {\n    \"vscode\": \"^1.84.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onStartupFinished\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"code-machine-container\",\n          \"title\": \"Code Machine\",\n          \"icon\": \"$(beaker)\"\n        }\n      ]\n    },\n    \"views\": {\n      \"code-machine-container\": [\n        {\n          \"id\": \"codeMachine.projectState\",\n          \"name\": \"Project State\"\n        },\n        {\n          \"id\": \"codeMachine.taskBoard\",\n          \"name\": \"Task Board\"\n        },\n        {\n          \"id\": \"codeMachine.artifacts\",\n          \"name\": \"Artifacts\"\n        }\n      ]\n    }\n  },\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.84.0\",\n    \"@types/mocha\": \"^10.0.6\",\n    \"@types/node\": \"18.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.9.0\",\n    \"@typescript-eslint/parser\": \"^6.9.0\",\n    \"eslint\": \"^8.52.0\",\n    \"glob\": \"^10.3.10\",\n    \"mocha\": \"^10.2.0\",\n    \"typescript\": \"^5.2.2\",\n    \"@vscode/test-electron\": \"^2.3.6\"\n  }\n}"
            },
            {
                "path": "docs/diagrams/workflow_state.mmd",
                "content": "stateDiagram-v2\n    direction LR\n\n    [*] --> Concept: Start New Project\n\n    Concept --> Specs: Generate Specs\n    Specs --> Arch: Approve & Lock Specs\n    Arch --> Plan: Approve Architecture\n    Plan --> Build: Approve Plan\n    Build --> [*]: Finish"
            },
            {
                "path": "src/controllers/WorkflowController.ts",
                "content": "export enum Phase {\n    Concept,\n    Specs,\n    Arch,\n    Plan,\n    Build\n}\n\nexport class WorkflowController {\n    private _currentPhase: Phase;\n\n    constructor() {\n        this._currentPhase = Phase.Concept;\n    }\n\n    public get currentPhase(): Phase {\n        return this._currentPhase;\n    }\n}"
            },
            {
                "path": "package.json",
                "content": "{\n  \"name\": \"code-machine-orchestrator\",\n  \"displayName\": \"Code Machine Orchestrator\",\n  \"description\": \"A VS Code extension to orchestrate a requirements-to-code CLI pipeline.\",\n  \"publisher\": \"CodeMachine\",\n  \"version\": \"0.0.1\",\n  \"engines\": {\n    \"vscode\": \"^1.84.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onStartupFinished\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"code-machine-container\",\n          \"title\": \"Code Machine\",\n          \"icon\": \"$(beaker)\"\n        }\n      ]\n    },\n    \"views\": {\n      \"code-machine-container\": [\n        {\n          \"id\": \"codeMachine.projectState\",\n          \"name\": \"Project State\"\n        },\n        {\n          \"id\": \"codeMachine.taskBoard\",\n          \"name\": \"Task Board\"\n        },\n        {\n          \"id\": \"codeMachine.artifacts\",\n          \"name\": \"Artifacts\"\n        }\n      ]\n    }\n  },\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.84.0\",\n    \"@types/mocha\": \"^10.0.6\",\n    \"@types/node\": \"18.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.9.0\",\n    \"@typescript-eslint/parser\": \"^6.9.0\",\n    \"eslint\": \"^8.52.0\",\n    \"glob\": \"^10.3.10\",\n    \"mocha\": \"^10.2.0\",\n    \"typescript\": \"^5.2.2\",\n    \"@vscode/test-electron\": \"^2.3.6\"\n  }\n}"
            },
            {
                "path": "docs/diagrams/workflow_state.mmd",
                "content": "stateDiagram-v2\n    direction LR\n\n    [*] --> Concept: Start New Project\n\n    Concept --> Specs: Generate Specs\n    Specs --> Arch: Approve & Lock Specs\n    Arch --> Plan: Approve Architecture\n    Plan --> Build: Approve Plan\n    Build --> [*]: Finish"
            },
            {
                "path": "src/controllers/WorkflowController.ts",
                "content": "export enum Phase {\n    Concept,\n    Specs,\n    Arch,\n    Plan,\n    Build\n}\n\nexport class WorkflowController {\n    private _currentPhase: Phase;\n\n    constructor() {\n        this._currentPhase = Phase.Concept;\n    }\n\n    public get currentPhase(): Phase {\n        return this._currentPhase;\n    }\n}"
            }
        ]
    },
    {
        "name": "I2.T3",
        "context": {
            "task_id": "I2.T3",
            "iteration_id": "I2",
            "iteration_goal": "Implement the Activity Bar container, the Sidebar layout, and the State Machine logic to track the project phase.",
            "description": "Implement `ArtifactWatcher`. Use `vscode.workspace.createFileSystemWatcher` to monitor `artifacts/*.{md,json}`. When files change, emit an event to the `WorkflowController` to update the state (e.g., if `requirements.md` is created, move phase to Specs).",
            "agent_type_hint": "BackendAgent",
            "inputs": "Requirement 5.3 (Data Watching).",
            "target_files": [
                "src/services/ArtifactWatcher.ts"
            ],
            "input_files": [
                "src/controllers/WorkflowController.ts"
            ],
            "deliverables": "Watcher service.",
            "acceptance_criteria": "Creating a dummy file in `artifacts/` triggers a log message in the extension.",
            "dependencies": [
                "I2.T2"
            ],
            "parallelizable": false
        },
        "output": "Okay, I'm ready to proceed with task I2.T3. Here is my plan:\n\n1.  **Create `src/services/ArtifactWatcher.ts`**: This new file will contain the `ArtifactWatcher` class. It will use `vscode.workspace.createFileSystemWatcher` to monitor the `artifacts` directory for changes to `.md` and `.json` files.\n2.  **Update `src/controllers/WorkflowController.ts`**: I will add a new public method, `updatePhaseFromArtifact(uri: vscode.Uri)`, which will be called by the watcher. This method will contain the logic to update the project's phase based on the name of the file that was created or changed.\n3.  **Update `src/extension.ts`**: I will import the new `ArtifactWatcher`, instantiate it in the `activate` function, and register it as a disposable in the extension's context. This will connect the watcher to the `WorkflowController` and ensure its lifecycle is managed correctly.\n\nThis approach directly addresses the requirements and acceptance criteria for the task.\n\nHere are the file modifications.\n\n~~~typescript\n#- file: src/services/ArtifactWatcher.ts\nimport * as vscode from 'vscode';\nimport { WorkflowController } from '../controllers/WorkflowController';\n\nexport class ArtifactWatcher implements vscode.Disposable {\n    private _watcher: vscode.FileSystemWatcher;\n    private _workflowController: WorkflowController;\n\n    constructor(workflowController: WorkflowController) {\n        this._workflowController = workflowController;\n\n        // A robust pattern to watch for artifacts in any subfolder of the workspace\n        const globPattern = '**/artifacts/*.{md,json}';\n        this._watcher = vscode.workspace.createFileSystemWatcher(globPattern);\n\n        this._watcher.onDidCreate(uri => this.onArtifactCreated(uri));\n        this._watcher.onDidChange(uri => this.onArtifactChanged(uri));\n        // Optional: handle deletion if needed in the future\n        // this._watcher.onDidDelete(uri => this.onArtifactDeleted(uri));\n    }\n\n    private onArtifactCreated(uri: vscode.Uri): void {\n        console.log(`Artifact created: ${uri.fsPath}`);\n        this._workflowController.updatePhaseFromArtifact(uri);\n    }\n\n    private onArtifactChanged(uri: vscode.Uri): void {\n        console.log(`Artifact changed: ${uri.fsPath}`);\n        this._workflowController.updatePhaseFromArtifact(uri);\n    }\n\n    public dispose() {\n        this._watcher.dispose();\n    }\n}\n~~~\n~~~typescript\n#- file: src/controllers/WorkflowController.ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\n\nexport enum Phase {\n    Concept,\n    Specs,\n    Arch,\n    Plan,\n    Build\n}\n\nexport class WorkflowController {\n    private _currentPhase: Phase;\n\n    constructor() {\n        this._currentPhase = Phase.Concept;\n    }\n\n    public get currentPhase(): Phase {\n        return this._currentPhase;\n    }\n\n    public updatePhaseFromArtifact(uri: vscode.Uri): void {\n        const filename = path.basename(uri.fsPath);\n\n        switch (filename) {\n            case 'requirements.md':\n                this._currentPhase = Phase.Specs;\n                console.log(`Phase changed to Specs based on creation of ${filename}`);\n                break;\n            case 'architecture.md':\n                this._currentPhase = Phase.Arch;\n                console.log(`Phase changed to Arch based on creation of ${filename}`);\n                break;\n            // Add other cases as needed for plan.md, todo.json etc.\n        }\n    }\n}\n~~~\n~~~edits\n#- file: src/extension.ts\n***start_edit\nLITERAL\n***search\nimport { WorkflowController, Phase } from './controllers/WorkflowController';\n***replace\nimport { WorkflowController, Phase } from './controllers/WorkflowController';\nimport { ArtifactWatcher } from './services/ArtifactWatcher';\n***description\nImport the new ArtifactWatcher service to be used in the activate function.\n***end_edit\n***start_edit\nLITERAL\n***search\n\tconst workflowController = new WorkflowController();\n\toutputChannel.appendLine(`Workflow initialized in phase: ${Phase[workflowController.currentPhase]}`);\n\n\tcontext.subscriptions.push(outputChannel);\n***replace\n\tconst workflowController = new WorkflowController();\n\toutputChannel.appendLine(`Workflow initialized in phase: ${Phase[workflowController.currentPhase]}`);\n\n\tconst artifactWatcher = new ArtifactWatcher(workflowController);\n\n\tcontext.subscriptions.push(outputChannel, artifactWatcher);\n***description\nInstantiate the ArtifactWatcher, passing the WorkflowController to it, and add the watcher to the extension's subscriptions to manage its lifecycle.\n***end_edit\n~~~",
        "iteration_id": "I2",
        "completed": true,
        "target_files": [
            "src/services/ArtifactWatcher.ts"
        ],
        "input_files": [
            "src/controllers/WorkflowController.ts"
        ],
        "files": [
            {
                "path": "src/controllers/WorkflowController.ts",
                "content": "export enum Phase {\n    Concept,\n    Specs,\n    Arch,\n    Plan,\n    Build\n}\n\nexport class WorkflowController {\n    private _currentPhase: Phase;\n\n    constructor() {\n        this._currentPhase = Phase.Concept;\n    }\n\n    public get currentPhase(): Phase {\n        return this._currentPhase;\n    }\n}"
            },
            {
                "path": "src/services/ArtifactWatcher.ts",
                "content": "import * as vscode from 'vscode';\nimport { WorkflowController } from '../controllers/WorkflowController';\n\nexport class ArtifactWatcher implements vscode.Disposable {\n    private _watcher: vscode.FileSystemWatcher;\n    private _workflowController: WorkflowController;\n\n    constructor(workflowController: WorkflowController) {\n        this._workflowController = workflowController;\n\n        // A robust pattern to watch for artifacts in any subfolder of the workspace\n        const globPattern = '**/artifacts/*.{md,json}';\n        this._watcher = vscode.workspace.createFileSystemWatcher(globPattern);\n\n        this._watcher.onDidCreate(uri => this.onArtifactCreated(uri));\n        this._watcher.onDidChange(uri => this.onArtifactChanged(uri));\n        // Optional: handle deletion if needed in the future\n        // this._watcher.onDidDelete(uri => this.onArtifactDeleted(uri));\n    }\n\n    private onArtifactCreated(uri: vscode.Uri): void {\n        console.log(`Artifact created: ${uri.fsPath}`);\n        this._workflowController.updatePhaseFromArtifact(uri);\n    }\n\n    private onArtifactChanged(uri: vscode.Uri): void {\n        console.log(`Artifact changed: ${uri.fsPath}`);\n        this._workflowController.updatePhaseFromArtifact(uri);\n    }\n\n    public dispose() {\n        this._watcher.dispose();\n    }\n}"
            },
            {
                "path": "src/controllers/WorkflowController.ts",
                "content": "import * as vscode from 'vscode';\nimport * as path from 'path';\n\nexport enum Phase {\n    Concept,\n    Specs,\n    Arch,\n    Plan,\n    Build\n}\n\nexport class WorkflowController {\n    private _currentPhase: Phase;\n\n    constructor() {\n        this._currentPhase = Phase.Concept;\n    }\n\n    public get currentPhase(): Phase {\n        return this._currentPhase;\n    }\n\n    public updatePhaseFromArtifact(uri: vscode.Uri): void {\n        const filename = path.basename(uri.fsPath);\n\n        switch (filename) {\n            case 'requirements.md':\n                this._currentPhase = Phase.Specs;\n                console.log(`Phase changed to Specs based on creation of ${filename}`);\n                break;\n            case 'architecture.md':\n                this._currentPhase = Phase.Arch;\n                console.log(`Phase changed to Arch based on creation of ${filename}`);\n                break;\n            // Add other cases as needed for plan.md, todo.json etc.\n        }\n    }\n}"
            }
        ]
    },
    {
        "name": "I3.T1",
        "context": {
            "task_id": "I3.T1",
            "iteration_id": "I3",
            "iteration_goal": "Implement the Prompt Wizard (Webview) and the Architecture Preview with Mermaid rendering.",
            "description": "Create the \"New Project\" command and Webview. The Webview should accept a Project Name and Prompt, then call `CliService` (mocked) to generate `requirements.md`.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Requirement 3.2 (Phase 1).",
            "target_files": [
                "src/views/webviews/PromptPanel.ts",
                "src/commands/newProject.ts"
            ],
            "input_files": [
                "src/services/CliService.ts"
            ],
            "deliverables": "Interactive Webview form.",
            "acceptance_criteria": "Submitting the form triggers the CLI and opens `requirements.md` in the editor.",
            "dependencies": [
                "I1.T3"
            ],
            "parallelizable": false
        },
        "output": "I will now implement the \"New Project\" command and its associated Webview. This involves creating a new command, a Webview panel class to handle the UI and logic, and updating the extension's entry point and manifest to register everything correctly. I will also make a necessary modification to the `CliService` to support specifying a working directory for the command execution.\n\n### 1. Registering the Command and Activation Event\n\nFirst, I'll update `package.json` to define the new command `codemachine.newProject` and add an `onCommand` activation event to ensure the extension loads when the command is invoked.\n\n~~~edits\n#- file: package.json\n***start_edit\nLITERAL\n***search\n  \"activationEvents\": [\n    \"onStartupFinished\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"viewsContainers\": {\n***replace\n  \"activationEvents\": [\n    \"onStartupFinished\",\n    \"onCommand:codemachine.newProject\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"commands\": [\n      {\n        \"command\": \"codemachine.newProject\",\n        \"title\": \"Code Machine: New Project\"\n      }\n    ],\n    \"viewsContainers\": {\n***description\nRegister the 'codemachine.newProject' command so it appears in the Command Palette and add a corresponding activation event to ensure the extension is loaded when the command is triggered.\n***end_edit\n~~~\n\n### 2. Wiring the Command in `extension.ts`\n\nNext, I'll modify the main `extension.ts` file to import and call the registration function for our new command, ensuring it's available when the extension activates.\n\n~~~edits\n#- file: src/extension.ts\n***start_edit\nLITERAL\n***search\nimport * as vscode from 'vscode';\nimport { WorkflowController, Phase } from './controllers/WorkflowController';\nimport { ArtifactWatcher } from './services/ArtifactWatcher';\n\nexport function activate(context: vscode.ExtensionContext) {\n***replace\nimport * as vscode from 'vscode';\nimport { WorkflowController, Phase } from './controllers/WorkflowController';\nimport { ArtifactWatcher } from './services/ArtifactWatcher';\nimport { registerNewProjectCommand } from './commands/newProject';\n\nexport function activate(context: vscode.ExtensionContext) {\n***description\nImport the registration function for the new project command.\n***end_edit\n***start_edit\nLITERAL\n***search\n\tconst artifactWatcher = new ArtifactWatcher(workflowController, outputChannel);\n\n\tcontext.subscriptions.push(outputChannel, artifactWatcher);\n}\n***replace\n\tconst artifactWatcher = new ArtifactWatcher(workflowController, outputChannel);\n\n\t// Register commands\n\tregisterNewProjectCommand(context);\n\n\tcontext.subscriptions.push(outputChannel, artifactWatcher);\n}\n***description\nRegister the 'newProject' command during extension activation to make it available to the user.\n***end_edit\n~~~\n\n### 3. Creating the Command Logic\n\nI'll create a new file, `src/commands/newProject.ts`, to encapsulate the logic for the command. Its sole responsibility is to register the command and launch the Webview panel when triggered.\n\n~~~\n#- file: src/commands/newProject.ts\nimport * as vscode from 'vscode';\nimport { PromptPanel } from '../views/webviews/PromptPanel';\n\nexport function registerNewProjectCommand(context: vscode.ExtensionContext) {\n    const command = vscode.commands.registerCommand('codemachine.newProject', () => {\n        // This code is executed when the command is called\n        PromptPanel.createOrShow(context.extensionUri);\n    });\n\n    context.subscriptions.push(command);\n}\n~~~\n\n### 4. Enhancing `CliService` for Directory Context\n\nTo ensure the CLI command runs in the correct project folder, I'll update `CliService` to accept an optional `cwd` (current working directory) parameter.\n\n~~~edits\n#- file: src/services/CliService.ts\n***start_edit\nLITERAL\n***search\n     * @param outputChannel The VS Code output channel to stream stdout and stderr to.\n     * @returns A promise that resolves if the command exits with code 0, and rejects otherwise.\n     */\n    public execute(command: string, args: string[], outputChannel: vscode.OutputChannel): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            outputChannel.appendLine(`> Running command: ${command} ${args.join(' ')}`);\n\n            const child = spawn(command, args);\n***replace\n     * @param outputChannel The VS Code output channel to stream stdout and stderr to.\n     * @param cwd The working directory to run the command in.\n     * @returns A promise that resolves if the command exits with code 0, and rejects otherwise.\n     */\n    public execute(command: string, args: string[], outputChannel: vscode.OutputChannel, cwd?: string): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            if (cwd) {\n                outputChannel.appendLine(`> Working directory: ${cwd}`);\n            }\n            outputChannel.appendLine(`> Running command: ${command} ${args.join(' ')}`);\n\n            const child = spawn(command, args, { cwd });\n***description\nAdd an optional 'cwd' parameter to the execute method to specify the command's working directory. This is crucial for running the CLI in the context of the user's workspace.\n***end_edit\n~~~\n\n### 5. Implementing the `PromptPanel` Webview\n\nFinally, I'll create the `src/views/webviews/PromptPanel.ts` file. This class manages the entire lifecycle of the \"New Project\" webview, from rendering the HTML form to handling the form submission, calling the `CliService`, and opening the resulting `requirements.md` file.\n\n~~~\n#- file: src/views/webviews/PromptPanel.ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport { CliService } from '../../services/CliService';\n\n/**\n * Manages the webview panel for creating a new project.\n * This panel displays a form to capture project name and initial prompt.\n */\nexport class PromptPanel {\n    public static currentPanel: PromptPanel | undefined;\n\n    public static readonly viewType = 'newProject';\n\n    private readonly _panel: vscode.WebviewPanel;\n    private readonly _extensionUri: vscode.Uri;\n    private _disposables: vscode.Disposable[] = [];\n\n    public static createOrShow(extensionUri: vscode.Uri) {\n        const column = vscode.window.activeTextEditor\n            ? vscode.window.activeTextEditor.viewColumn\n            : undefined;\n\n        // If we already have a panel, show it.\n        if (PromptPanel.currentPanel) {\n            PromptPanel.currentPanel._panel.reveal(column);\n            return;\n        }\n\n        // Otherwise, create a new panel.\n        const panel = vscode.window.createWebviewPanel(\n            PromptPanel.viewType,\n            'Code Machine: New Project',\n            column || vscode.ViewColumn.One,\n            {\n                // Enable javascript in the webview\n                enableScripts: true,\n            }\n        );\n\n        PromptPanel.currentPanel = new PromptPanel(panel, extensionUri);\n    }\n\n    private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {\n        this._panel = panel;\n        this._extensionUri = extensionUri;\n\n        // Set the webview's initial html content\n        this._update();\n\n        // Listen for when the panel is disposed\n        // This happens when the user closes the panel or when the panel is closed programmatically\n        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);\n\n        // Handle messages from the webview\n        this._panel.webview.onDidReceiveMessage(\n            async (message) => {\n                switch (message.command) {\n                    case 'submit':\n                        await this.handleSubmit(message.payload.projectName, message.payload.prompt);\n                        return;\n                }\n            },\n            null,\n            this._disposables\n        );\n    }\n\n    private async handleSubmit(projectName: string, prompt: string) {\n        if (!vscode.workspace.workspaceFolders || vscode.workspace.workspaceFolders.length === 0) {\n            vscode.window.showErrorMessage('Please open a workspace folder to create a new project.');\n            return;\n        }\n\n        const workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;\n        const outputChannel = vscode.window.createOutputChannel('Code Machine');\n        const cliService = new CliService();\n\n        await vscode.window.withProgress({\n            location: vscode.ProgressLocation.Notification,\n            title: \"Generating project requirements...\",\n            cancellable: false\n        }, async (progress) => {\n            progress.report({ increment: 0, message: \"Starting CLI...\" });\n            try {\n                // This path assumes the mock CLI from I1.T3 is located in `test/mocks/`.\n                const cliPath = path.join(this._extensionUri.fsPath, 'test', 'mocks', 'mock_cli.py');\n                \n                // The mock CLI needs to create `requirements.md` in the `cwd`.\n                await cliService.execute('python', [cliPath, '--prompt', prompt, '--project-name', projectName], outputChannel, workspaceRoot);\n                \n                progress.report({ increment: 100, message: \"Requirements generated.\" });\n                \n                // Close the webview panel\n                this.dispose();\n\n                // Open the requirements.md file\n                const requirementsPath = vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, 'requirements.md');\n                const document = await vscode.workspace.openTextDocument(requirementsPath);\n                await vscode.window.showTextDocument(document);\n\n            } catch (error) {\n                let errorMessage = 'An unknown error occurred.';\n                if (error instanceof Error) {\n                    errorMessage = error.message;\n                }\n                vscode.window.showErrorMessage(`Failed to generate project: ${errorMessage}`);\n            }\n        });\n    }\n\n    public dispose() {\n        PromptPanel.currentPanel = undefined;\n\n        // Clean up our resources\n        this._panel.dispose();\n\n        while (this._disposables.length) {\n            const x = this._disposables.pop();\n            if (x) {\n                x.dispose();\n            }\n        }\n    }\n\n    private _update() {\n        const webview = this._panel.webview;\n        this._panel.title = 'Code Machine: New Project';\n        this._panel.webview.html = this._getHtmlForWebview(webview);\n    }\n\n    private _getHtmlForWebview(webview: vscode.Webview) {\n        // Use a nonce to only allow specific scripts to be run\n        const nonce = getNonce();\n\n        return `<!DOCTYPE html>\n\t\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n                <title>New Code Machine Project</title>\n                <style>\n                    body { font-family: var(--vscode-font-family); color: var(--vscode-editor-foreground); background-color: var(--vscode-editor-background); }\n                    .container { padding: 20px; }\n                    label { display: block; margin-bottom: 5px; }\n                    input, textarea {\n                        width: 100%;\n                        padding: 8px;\n                        margin-bottom: 15px;\n                        border: 1px solid var(--vscode-input-border);\n                        background-color: var(--vscode-input-background);\n                        color: var(--vscode-input-foreground);\n                        box-sizing: border-box; /* Important */\n                    }\n                    textarea {\n                        resize: vertical;\n                        min-height: 100px;\n                    }\n                    button {\n                        background-color: var(--vscode-button-background);\n                        color: var(--vscode-button-foreground);\n                        border: none;\n                        padding: 10px 15px;\n                        cursor: pointer;\n                        text-align: center;\n                    }\n                    button:hover {\n                        background-color: var(--vscode-button-hoverBackground);\n                    }\n                </style>\n\t\t\t</head>\n\t\t\t<body>\n                <div class=\"container\">\n                    <h1>New Code Machine Project</h1>\n                    <form id=\"new-project-form\">\n                        <label for=\"projectName\">Project Name</label>\n                        <input type=\"text\" id=\"projectName\" name=\"projectName\" required />\n\n                        <label for=\"prompt\">Prompt</label>\n                        <textarea id=\"prompt\" name=\"prompt\" rows=\"10\" required></textarea>\n\n                        <button type=\"submit\">Generate Requirements</button>\n                    </form>\n                </div>\n\n\t\t\t\t<script nonce=\"${nonce}\">\n\t\t\t\t\t(function() {\n\t\t\t\t\t\tconst vscode = acquireVsCodeApi();\n\t\t\t\t\t\tconst form = document.getElementById('new-project-form');\n\n\t\t\t\t\t\tform.addEventListener('submit', (event) => {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tconst projectNameInput = document.getElementById('projectName');\n\t\t\t\t\t\t\tconst promptInput = document.getElementById('prompt');\n\n\t\t\t\t\t\t\tif (projectNameInput && promptInput) {\n                                const projectName = projectNameInput.value;\n                                const prompt = promptInput.value;\n\t\t\t\t\t\t\t\tvscode.postMessage({\n\t\t\t\t\t\t\t\t\tcommand: 'submit',\n\t\t\t\t\t\t\t\t\tpayload: {\n                                        projectName,\n                                        prompt\n                                    }\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}());\n\t\t\t\t</script>\n\t\t\t</body>\n\t\t\t</html>`;\n    }\n}\n\nfunction getNonce() {\n    let text = '';\n    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    for (let i = 0; i < 32; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text;\n}\n~~~",
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "src/views/webviews/PromptPanel.ts",
            "src/commands/newProject.ts"
        ],
        "input_files": [
            "src/services/CliService.ts"
        ],
        "files": [
            {
                "path": "src/services/CliService.ts",
                "content": "import * as vscode from 'vscode';\nimport { spawn } from 'child_process';\n\nexport class CliService {\n    /**\n     * Executes a command-line tool.\n     * \n     * @param command The command to execute (e.g., 'python').\n     * @param args An array of string arguments.\n     * @param outputChannel The VS Code output channel to stream stdout and stderr to.\n     * @returns A promise that resolves if the command exits with code 0, and rejects otherwise.\n     */\n    public execute(command: string, args: string[], outputChannel: vscode.OutputChannel): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            outputChannel.appendLine(`> Running command: ${command} ${args.join(' ')}`);\n\n            const child = spawn(command, args);\n\n            // Stream stdout\n            if (child.stdout) {\n                child.stdout.on('data', (data: Buffer) => {\n                    outputChannel.append(data.toString());\n                });\n            }\n\n            // Stream stderr\n            if (child.stderr) {\n                child.stderr.on('data', (data: Buffer) => {\n                    outputChannel.append(data.toString());\n                });\n            }\n\n            // Handle spawn errors (e.g., command not found)\n            child.on('error', (error) => {\n                outputChannel.appendLine(`Error spawning process: ${error.message}`);\n                reject(error);\n            });\n\n            // Handle process exit\n            child.on('close', (code) => {\n                if (code === 0) {\n                    outputChannel.appendLine(`> Command finished with exit code ${code}.`);\n                    resolve();\n                } else {\n                    const errorMessage = `Command failed with exit code ${code}.`;\n                    outputChannel.appendLine(`> ${errorMessage}`);\n                    reject(new Error(errorMessage));\n                }\n            });\n        });\n    }\n}"
            }
        ]
    },
    {
        "name": "I3.T2",
        "context": {
            "task_id": "I3.T2",
            "iteration_id": "I3",
            "iteration_goal": "Implement the Prompt Wizard (Webview) and the Architecture Preview with Mermaid rendering.",
            "description": "Implement the Architecture Preview logic. Create a command that parses `architecture.md`, extracts Mermaid blocks, and renders them in a VS Code Webview Panel alongside the text.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Requirement 3.3 (Phase 2).",
            "target_files": [
                "src/views/webviews/ArchitecturePreview.ts"
            ],
            "input_files": [
                "src/controllers/WorkflowController.ts"
            ],
            "deliverables": "Preview logic using Mermaid.js CDN or bundled library.",
            "acceptance_criteria": "Opening a markdown file with mermaid blocks and running the command renders the diagram visually.",
            "dependencies": [],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I3",
        "completed": false,
        "target_files": [
            "src/views/webviews/ArchitecturePreview.ts"
        ],
        "input_files": [
            "src/controllers/WorkflowController.ts"
        ],
        "files": []
    },
    {
        "name": "I4.T1",
        "context": {
            "task_id": "I4.T1",
            "iteration_id": "I4",
            "iteration_goal": "Implement the interactive Tree View for `todo.json` allowing visualization and manipulation of the build plan.",
            "description": "Define the JSON Schema for `todo.json`. It must support nested iterations and tasks with status, id, and dependencies.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Requirement 3.4 (Plan Board).",
            "target_files": [
                "schemas/todo_schema.json"
            ],
            "input_files": [],
            "deliverables": "JSON Schema file.",
            "acceptance_criteria": "Validates a sample `todo.json` correctly.",
            "dependencies": [],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "schemas/todo_schema.json"
        ],
        "input_files": [],
        "files": []
    },
    {
        "name": "I4.T2",
        "context": {
            "task_id": "I4.T2",
            "iteration_id": "I4",
            "iteration_goal": "Implement the interactive Tree View for `todo.json` allowing visualization and manipulation of the build plan.",
            "description": "Implement `TaskTreeProvider` implementing `vscode.TreeDataProvider`. It should read `todo.json` and render Iterations as collapsible nodes and Tasks as leaf nodes.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Requirement 3.4, `schemas/todo_schema.json`.",
            "target_files": [
                "src/views/sidebar/TaskTreeProvider.ts"
            ],
            "input_files": [
                "schemas/todo_schema.json"
            ],
            "deliverables": "Tree View implementation.",
            "acceptance_criteria": "The \"Task Board\" view in the sidebar populates with data from a sample `todo.json`.",
            "dependencies": [
                "I4.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "src/views/sidebar/TaskTreeProvider.ts"
        ],
        "input_files": [
            "schemas/todo_schema.json"
        ],
        "files": []
    },
    {
        "name": "I4.T3",
        "context": {
            "task_id": "I4.T3",
            "iteration_id": "I4",
            "iteration_goal": "Implement the interactive Tree View for `todo.json` allowing visualization and manipulation of the build plan.",
            "description": "Implement \"Approve Plan\" command. This updates the `WorkflowController` state to \"Build\" and enables the execution controls.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Requirement 3.4 (Approval).",
            "target_files": [
                "src/commands/approvePlan.ts"
            ],
            "input_files": [
                "src/controllers/WorkflowController.ts"
            ],
            "deliverables": "Command registration.",
            "acceptance_criteria": "Clicking approve changes the status indicator in the sidebar.",
            "dependencies": [
                "I2.T2"
            ],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I4",
        "completed": false,
        "target_files": [
            "src/commands/approvePlan.ts"
        ],
        "input_files": [
            "src/controllers/WorkflowController.ts"
        ],
        "files": []
    },
    {
        "name": "I5.T1",
        "context": {
            "task_id": "I5.T1",
            "iteration_id": "I5",
            "iteration_goal": "Implement the granular execution of tasks using the CLI and basic Git integration.",
            "description": "Generate a Sequence Diagram for the Build Loop. Show: User clicks \"Run Task\" -> Extension calls CLI -> CLI writes code -> Extension calls Git -> Extension opens Diff.",
            "agent_type_hint": "DiagrammingAgent",
            "inputs": "Requirement 3.5 (Iterative Build).",
            "target_files": [
                "docs/diagrams/build_loop_sequence.puml"
            ],
            "input_files": [],
            "deliverables": "PlantUML sequence diagram.",
            "acceptance_criteria": "Clearly shows the interaction between `CliService` and `GitService`.",
            "dependencies": [],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "docs/diagrams/build_loop_sequence.puml"
        ],
        "input_files": [],
        "files": []
    },
    {
        "name": "I5.T2",
        "context": {
            "task_id": "I5.T2",
            "iteration_id": "I5",
            "iteration_goal": "Implement the granular execution of tasks using the CLI and basic Git integration.",
            "description": "Implement `GitService`. Wrapper around `simple-git` or shell commands. Needs methods: `commit(msg)`, `resetHard()`, `getDiff()`, `init()`.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Requirement 4.5.",
            "target_files": [
                "src/services/GitService.ts"
            ],
            "input_files": [],
            "deliverables": "Git service class.",
            "acceptance_criteria": "Unit tests verify it can commit and reset a test repo.",
            "dependencies": [],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "src/services/GitService.ts"
        ],
        "input_files": [],
        "files": []
    },
    {
        "name": "I5.T3",
        "context": {
            "task_id": "I5.T3",
            "iteration_id": "I5",
            "iteration_goal": "Implement the granular execution of tasks using the CLI and basic Git integration.",
            "description": "Implement `runTask` command. It should take a `taskId`, call `CliService.run(taskId)`, and upon success, trigger `GitService` to stage changes (but not commit yet, or commit to a temp branch depending on strategy).",
            "agent_type_hint": "BackendAgent",
            "inputs": "Requirement 5.4.",
            "target_files": [
                "src/controllers/BuildController.ts"
            ],
            "input_files": [
                "src/services/CliService.ts",
                "src/services/GitService.ts"
            ],
            "deliverables": "Logic to run a specific task.",
            "acceptance_criteria": "Running a task triggers the mock CLI and results in a git status change.",
            "dependencies": [
                "I1.T3",
                "I5.T2"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I5",
        "completed": false,
        "target_files": [
            "src/controllers/BuildController.ts"
        ],
        "input_files": [
            "src/services/CliService.ts",
            "src/services/GitService.ts"
        ],
        "files": []
    },
    {
        "name": "I6.T1",
        "context": {
            "task_id": "I6.T1",
            "iteration_id": "I6",
            "iteration_goal": "Implement the \"Diff Review\" UI (Accept/Reject/Retry) and the QA status visualization.",
            "description": "Implement the \"Diff View\" trigger. When a task finishes, use `vscode.commands.executeCommand('git.openChange', ...)` to show the diff of the generated files.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Requirement 3.5.",
            "target_files": [
                "src/controllers/ReviewController.ts"
            ],
            "input_files": [
                "src/controllers/BuildController.ts"
            ],
            "deliverables": "Logic to open the native VS Code diff editor.",
            "acceptance_criteria": "After `runTask` completes, the editor splits and shows the diff.",
            "dependencies": [
                "I5.T3"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "src/controllers/ReviewController.ts"
        ],
        "input_files": [
            "src/controllers/BuildController.ts"
        ],
        "files": []
    },
    {
        "name": "I6.T2",
        "context": {
            "task_id": "I6.T2",
            "iteration_id": "I6",
            "iteration_goal": "Implement the \"Diff Review\" UI (Accept/Reject/Retry) and the QA status visualization.",
            "description": "Implement \"Accept\" and \"Reject\" commands. \"Accept\" marks the task done in `todo.json`. \"Reject\" calls `GitService.resetHard()` and prompts the user for feedback (Input Box), then re-triggers `CliService` with the feedback.",
            "agent_type_hint": "BackendAgent",
            "inputs": "Requirement 3.5 (The Diff UX).",
            "target_files": [
                "src/commands/reviewCommands.ts"
            ],
            "input_files": [
                "src/controllers/ReviewController.ts",
                "src/services/GitService.ts"
            ],
            "deliverables": "Command logic for review actions.",
            "acceptance_criteria": "Rejecting reverts the file system to pre-task state.",
            "dependencies": [
                "I6.T1"
            ],
            "parallelizable": false
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "src/commands/reviewCommands.ts"
        ],
        "input_files": [
            "src/controllers/ReviewController.ts",
            "src/services/GitService.ts"
        ],
        "files": []
    },
    {
        "name": "I6.T3",
        "context": {
            "task_id": "I6.T3",
            "iteration_id": "I6",
            "iteration_goal": "Implement the \"Diff Review\" UI (Accept/Reject/Retry) and the QA status visualization.",
            "description": "Implement QA Status Badges. Update `TaskTreeProvider` to read `logs/<taskId>.log` (mocked) or CLI exit codes to determine status (Green/Red). Add decoration to the TreeItem.",
            "agent_type_hint": "FrontendAgent",
            "inputs": "Requirement 3.6 (QA Dashboard).",
            "target_files": [
                "src/views/sidebar/TaskTreeProvider.ts"
            ],
            "input_files": [
                "src/views/sidebar/TaskTreeProvider.ts"
            ],
            "deliverables": "Visual badges on tree items.",
            "acceptance_criteria": "Tasks show checkmarks or X icons based on status in `todo.json`.",
            "dependencies": [
                "I4.T2"
            ],
            "parallelizable": true
        },
        "output": null,
        "iteration_id": "I6",
        "completed": false,
        "target_files": [
            "src/views/sidebar/TaskTreeProvider.ts"
        ],
        "input_files": [
            "src/views/sidebar/TaskTreeProvider.ts"
        ],
        "files": []
    }
]